<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>NumPy | 未分類 | hydroculのメモ</title>
<meta name="google-site-verification" content="uOXuLX4TAlCnMv26zOR30sGJVaZeWwaQLijOrxZiDyI" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<link rel="stylesheet" href="https://raw.github.com/necolas/normalize.css/master/normalize.css" type="text/css" />
<link rel="stylesheet" href="../common/css/page.css" type="text/css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js"></script>
<script src="https://rawgithub.com/adobe-webplatform/Snap.svg/master/dist/snap.svg-min.js"></script>
<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../common/js/page.js"></script>
</head>
<body class="res">

<div id="breadcrumb">
  <a href="../">hydroculのメモ</a> &gt; <a href="../others/">未分類</a> &gt; <span>NumPy</span>
</div>

<div id="content">
  <h1 id="numpy">NumPy
<span class="article-date">2015/03/29</span></h1>

<p>NumPyは行列などの数値計算を高速に行うためのPythonのライブラリ。
SciPyというNumPyに付随するライブラリもあり、しばしばNumPyとSciPyの両方を使う。</p>

<p>NumPyには高速なベクトル演算のできる<code>ndarray</code>という多次元配列がある。配列に対するループ処理をPythonでいちいち書かなくてもいいような仕組みがたくさんあり、
<code>ndarray</code>がNumPyの目玉の1つか。</p>

<h2 id="80b18fd">インストール
<span class="article-date">2015/04/01</span></h2>

<p>Pythonとnumpy, scipy, pandas, matplotlib, scikit-learn, ipythonなどのライブラリやツールを一式インストールするとなにかと便利だが、これらをインストールする方法はいま(2015年3月)は以下がオススメ。</p>

<p>MacでPythonの機械学習環境構築(2015年2月版) | old school magic<br />
<a href="http://breakbee.hatenablog.jp/entry/2015/02/07/173451" target="_blank">http://breakbee.hatenablog.jp/entry/2015/02/07/173451</a></p>

<p>自分は、上記ページを参考に、Ubuntuに以下の手順でインストールしている。</p>

<ul>
  <li>pyenvをgitで手動でインストール</li>
  <li><code>pyenv install anaconda-2.1.0</code></li>
  <li><code>pyenv install anaconda3-2.1.0</code></li>
  <li><code>pyenv rehash</code></li>
  <li><code>pyenv local anaconda3-2.1.0</code></li>
</ul>

<p>このページの例ではすべてソースコードの先頭に</p>

<pre><code>import numpy as np
</code></pre>

<p>と書いて、<code>np</code> でNumPyを参照することを前提にしている。</p>

<h2 id="f127b2b">多次元配列ndarrayの生成
<span class="article-date">2015/03/29</span></h2>

<p>ndarrayは、<code>np.array</code>を使ってPythonの多次元配列から簡単に生成できる。</p>

<pre><code># 普通のPythonの配列
data = [[1.0, 2.0, 3.0], [11.0, 12.0, 13.0]]

# NumPyの多次元配列
npdata = np.array(data)
print(npdata)
# 出力結果
# [[  1.   2.   3.]
#  [ 11.  12.  13.]]
</code></pre>

<p><code>np.zeros</code> は要素をすべて <code>0.0</code> で埋めた配列を生成してくれる。引数には配列の次元を指定する。配列の要素はすべて浮動小数点数になる。</p>

<pre><code>npdata = np.zeros(3)
print(npdata)
# 出力結果
# [ 0.  0.  0.]

npdata = np.zeros((2, 3))
print(npdata)
# 出力結果
# [[ 0.  0.  0.]
#  [ 0.  0.  0.]]
</code></pre>

<p>同じように <code>np.ones</code> は <code>1.0</code> で埋めた配列になる。</p>

<pre><code>npdata = np.ones(3)
print(npdata)
# 出力結果
# [ 1.  1.  1.]

npdata = np.ones((2, 3))
print(npdata)
# 出力結果
# [[ 1.  1.  1.]
#  [ 1.  1.  1.]]
</code></pre>

<p><code>np.empty</code> は要素を初期化せずに配列を生成する。</p>

<pre><code>npdata = np.empty(3)
# 結果は実行するごとに異なりうる

npdata = np.empty((2, 3))
# 結果は実行するごとに異なりうる
</code></pre>

<p><code>np.arange</code> は0からの連番の配列を生成する。要素の型は整数になる。</p>

<pre><code>npdata = np.arange(5)
print(npdata)
# 出力結果
# [0 1 2 3 4]

print(npdata.dtype)
# 出力結果
# int64
</code></pre>

<p><code>np.eye</code> または <code>np.identity</code> は単位行列を2次元配列で生成する。この2つの使い方は同じ。要素の型は浮動小数点数になる。</p>

<pre><code>npdata = np.eye(5)
print(npdata)
# 出力結果
# [[ 1.  0.  0.  0.  0.]
#  [ 0.  1.  0.  0.  0.]
#  [ 0.  0.  1.  0.  0.]
#  [ 0.  0.  0.  1.  0.]
#  [ 0.  0.  0.  0.  1.]]
</code></pre>

<h2 id="4c03167">ndarrayの属性
<span class="article-date">2015/04/01</span></h2>

<p>ndarrayには<code>shape</code>という配列の次元をタプルで保存している属性と、
<code>dtype</code>という配列の要素の型を保存している属性がある。</p>

<pre><code>from pprint import pprint

npdata = np.array([[1.0, 2.0, 3.0], [11.0, 12.0, 13.0]])

# shapeは配列の次元を表すタプル
print(npdata.shape)
# 出力結果
# (2, 3)

# dtypeは配列の要素の型を表す
print(npdata.dtype)
# 出力結果
# float64

pprint(npdata.dtype)
# 出力結果
# dtype('float64')
</code></pre>

<h2 id="c6e8395">ndarrayの要素のデータ型
<span class="article-date">2015/04/01</span></h2>

<p>ndarrayを生成すると要素のデータ型はだいたいデフォルトでfloat64という浮動小数点型になる。
<code>np.arange</code>はint64という整数になる。</p>

<p>要素のデータ型は<code>dtype</code>という属性で確認することができる。</p>

<pre><code>from pprint import pprint

npdata = np.array([[1.0, 2.0, 3.0], [11.0, 12.0, 13.0]])

print(npdata.dtype)
# 出力結果
# float64

pprint(npdata.dtype)
# 出力結果
# dtype('float64')

# 整数のPython配列でndarrayを生成すると、int64になるみたい
npdata1 = np.array([1, 2, 3])
print(npdata1.dtype)
# 出力結果
# int64
</code></pre>

<p><code>np.array</code>に<code>dtype</code>という名前の引数を渡すことで生成するndarrayの要素型を指定できる。</p>

<pre><code>npdata = np.array([[1.0, 2.0, 3.0], [11.0, 12.0, 13.0]], dtype=np.int32)

print(npdata)
#  出力結果
# [[ 1  2  3]
#  [11 12 13]]

print(npdata.dtype)
#  出力結果
# int32
</code></pre>

<p>データ型には以下のようなものがある。</p>

<ul>
  <li>符号付き整数 int8, int16, int32, int64</li>
  <li>符号なし整数 uint8, uint16, uint32, uint64</li>
  <li>浮動小数点数 float16,float32, float64, float128</li>
  <li>複素数 complex64, complex128, complex256</li>
  <li>論理値 bool</li>
</ul>

<p>型名の数字はビット数を表す。複素数は浮動小数点2つで表されるので、complex64はfloat32 2つ分に相当する。</p>

<h2 id="d7b8a98">ndarrayのコピー
<span class="article-date">2015/04/01</span></h2>

<p><code>np.array</code> の引数にはPythonの配列だけでなくndarrayも渡すことができて、いずれも新しいndarrayを生成する。ndarrayを渡した場合は配列のコピーになる。</p>

<pre><code>npdata1 = np.array([1, 2, 3])
npdata2 = np.array(npdata1)
npdata2[0] = 10

print(npdata1)
# 出力結果
# [1 2 3]

print(npdata2)
# 出力結果
# [10  2  3]
</code></pre>

<p><code>np.asarray</code> は <code>np.array</code> とほとんど同じように使えるが、引数にndarrayを渡した場合は配列のコピーをせずに引数をそのまま帰す。</p>

<pre><code>npdata1 = np.array([1, 2, 3])
npdata2 = np.asarray(npdata1)
npdata2[0] = 10

print(npdata1)
# 出力結果
# [10  2  3]

print(npdata2)
# 出力結果
# [10  2  3]
</code></pre>

<h2 id="6ad0c29">ndarrayのデータ型の変換
<span class="article-date">2015/04/01</span></h2>

<p><code>astype</code>というメソッドでndarrayの要素のデータ型を別のものにしたndarrayを生成することができる。新しくndarrayを生成しているので、要素を変更してももとのndarrayには影響しない。</p>

<pre><code>npdata1 = np.array([1, 2, 3])
print(npdata1.dtype)
# 出力結果
# int64

npdata2 = npdata1.astype(np.float64)
print(npdata2.dtype)
# 出力結果
# float64

npdata2[0] = 10

print(npdata1)
# 出力結果
# [1 2 3]

print(npdata2)
# 出力結果
# [ 10.   2.   3.]
</code></pre>

<p>偶然同じデータ型を指定した場合は単なるコピーと同じになる。</p>

<pre><code>npdata1 = np.array([1, 2, 3])
npdata2 = npdata1.astype(np.int64)
npdata2[0] = 10

print(npdata1)
# 出力結果
# [1 2 3]

print(npdata2)
# 出力結果
# [10  2  3]
</code></pre>

<h2 id="10de200">ndarrayでのベクトル計算
<span class="article-date">2015/04/20</span></h2>

<p>同じ次元・大きさのndarray同士の四則演算を書くと、その要素ごとに演算して同じ次元・大きさのndarrayを生成してくれる。これをベクトル計算という。</p>

<p>このベクトル計算はNumPyのndarrayの大きな特徴の1つである。
NumPyの中では実際にはC言語で実装されたループ処理であるので、
Pythonでループを書くことなく、配列を高速に処理することができる。</p>

<pre><code>ndarr1 = np.array([[1., 2., 3.], [4., 5., 6.]])
ndarr2 = np.array([[10., 20., 30.], [40., 50., 60.]])

print(ndarr1 + ndarr2)
# 出力結果
# [[ 11.  22.  33.]
#  [ 44.  55.  66.]]

print(ndarr1 - ndarr2)
# 出力結果
# [[ -9. -18. -27.]
#  [-36. -45. -54.]]

print(ndarr1 * ndarr2)
# 出力結果
# [[  10.   40.   90.]
#  [ 160.  250.  360.]]

print(ndarr1 / ndarr2)
# 出力結果
# [[ 0.1  0.1  0.1]
#  [ 0.1  0.1  0.1]]
</code></pre>

<p>一方のndarrayの特定の次元の大きさが1の場合はブロードキャストという。以下はいろいろなブロードキャストの例。</p>

<p>一方のndarrayの内側の次元が大きさ1の例</p>

<pre><code>ndarr1 = np.array([[1], [2]])
ndarr2 = np.array([[10., 20., 30.], [40., 50., 60.]])

print(ndarr1 + ndarr2)
# 出力結果
# [[ 11.  21.  31.]
#  [ 42.  52.  62.]]
</code></pre>

<p>一方のndarrayの外側の次元が大きさ1の例</p>

<pre><code>ndarr1 = np.array([[1, 2, 3]])
ndarr2 = np.array([[10., 20., 30.], [40., 50., 60.]])

print(ndarr1 + ndarr2)
# 出力結果
# [[ 11.  22.  33.]
#  [ 41.  52.  63.]]
</code></pre>

<p>一方のndarrayの両方の次元が大きさ1の例</p>

<pre><code>ndarr1 = np.array([[1]])
ndarr2 = np.array([[10., 20., 30.], [40., 50., 60.]])

print(ndarr1 + ndarr2)
# 出力結果
# [[ 11.  21.  31.]
#  [ 41.  51.  61.]]
</code></pre>

<p>一方がndarrayではなく単なるスカラーでもよい。</p>

<pre><code>ndarr2 = np.array([[10., 20., 30.], [40., 50., 60.]])

print(1 + ndarr2)
# 出力結果
# [[ 11.  21.  31.]
#  [ 41.  51.  61.]]
</code></pre>

<p>1つ目のndarrayは外側の次元が大きさ1で、2つ目のndarrayは内側の次元が大きさ1の例</p>

<pre><code>ndarr1 = np.array([[1., 2., 3.]])
ndarr2 = np.array([[10.], [20.]])

print(ndarr1 + ndarr2)
# 出力結果
# [[ 11.  12.  13.]
#  [ 21.  22.  23.]]
</code></pre>

<h2 id="cc0319c">ndarrayのインデックスでの参照と代入
<span class="article-date">2015/04/20</span></h2>

<p>NumPyのndarrayは、Pythonの通常のリストと同様に <code>[]</code> でインデックスを指定して要素を参照・代入することができる。インデックスは0から始まる。インデックスを負にすると、後ろから数えてくれる点も、通常のリストと同様である。</p>

<pre><code>ndarr1 = np.array([0, 1, 2, 3, 4, 5])

print(ndarr1[1])
# 出力結果
# 1

# インデックスを負にすると後ろから数える
print(ndarr1[-1])
# 出力結果
# 5

ndarr1[0] = 10
print(ndarr1)
# 出力結果
# [10  1  2  3  4  5]

ndarr1[-1] = 30
print(ndarr1)
# 出力結果
# [10  1  2  3  4 30]
</code></pre>

<p>インデックスがサイズ以上の場合や、負の場合で後ろから数えても先頭を超えてしまう場合には
<code>IndexError: index 10 is out of bounds for axis 0 with size 6</code> というような例外が投げられる。</p>

<h2 id="7557d94">ndarrayのスライス表記の参照と代入
<span class="article-date">2015/04/20</span></h2>

<p>NumPyのndarrayは、<code>[a:b]</code> というような表記で範囲を指定して参照することができる。
<code>[]</code> の中をコロンで区切って、開始インデックスと終了インデックスを書く。終了インデックスの直前までになる。</p>

<p>これをスライス表記だとかスライシングなどという。</p>

<p>このスライス表記はPythonの通常のリストにもある仕組みだが、NumPyのndarrayが違う点は、代入もできることである。スライス表記に代入すると、もとのndarrayの一部をまとめて書き換えることができる。</p>

<pre><code>ndarr1 = np.array([0, 1, 2, 3, 4, 5])

print(ndarr1[1:3])
# 出力結果
# [1 2]

# スライス表記に同じ大きさの配列を代入すれば、それがそのままその位置に代入される
ndarr1[3:6] = [100., 200., 300.]
print(ndarr1)
# 出力結果
# [  0   1   2 100 200 300]
</code></pre>

<p>スライス表記に配列ではなく数値を代入すると、そのスライスの範囲にある要素すべてに同一の値が代入される。これをブロードキャストという。</p>

<pre><code># スライス表記に数値を代入すると、スライスの範囲全部が同じ値になる
ndarr1[3:5] = 20
print(ndarr1)
# 出力結果
# [ 0  1  2 20 20  5]
</code></pre>

<p>スライシングしたものを別の変数に入れると、そのスライスはビューになり、スライスを通してもとのndarrayを変更することができるようになる。</p>

<pre><code>ndarr1 = np.array([0, 1, 2, 3, 4, 5])

sl = ndarr1[3:6]

print(sl)
# 出力結果
# [3 4 5]

sl[0] = 100

print(sl)
# 出力結果
# [100   4   5]

print(ndarr1)
# 出力結果
# [  0   1   2 100   4   5]

sl[:] = 200

print(sl)
# 出力結果
# [200 200 200]

print(ndarr1)
# 出力結果
# [  0   1   2 200 200 200]
</code></pre>

<h2 id="35729ff">HOWTO</h2>

<h3 id="6eef005">TSVファイルを読み込む方法</h3>

<p>-&gt; <a href="../blog/2014/0216-load-tsv-python.html">TSVファイルを読み込む方法</a></p>

<h3 id="0050225">乱数の配列を取得するには
<span class="article-date">2014/05/18</span></h3>

<p>例</p>

<pre><code>import numpy as np

# 0.0 から 1.0 までの一様な乱数100個をnumpyの配列で生成
print(np.random.uniform(0.0, 1.0, 100))

# 平均0.0、標準偏差1.0の正規分布に従う乱数100個をnumpyの配列で生成
print(np.random.normal(0.0, 1.0, 100))

# λ=10 のポワソン分布に従う乱数100個をnumpyの整数の配列で生成
print(np.random.poisson(10, 100))
</code></pre>

<p>Random sampling (numpy.random) | NumPy v1.8 Manual<br />
<a href="http://docs.scipy.org/doc/numpy/reference/routines.random.html" target="_blank">http://docs.scipy.org/doc/numpy/reference/routines.random.html</a></p>

<h3 id="67bbfbb">行列から行単位または列単位で一部を取り出すには
<span class="article-date">2014/05/20</span></h3>

<p><a href="../programming_languages_diff/list/sub-list.html#python">スライス表記</a>はNumPyの多次元配列にも使える。</p>

<p>列単位で取り出す例</p>

<p>\[ \mathbf{X} =
    \begin{pmatrix}
      1 &amp; 2 &amp; 3 \\ 
      4 &amp; 5 &amp; 6 \\ 
      7 &amp; 8 &amp; 9 \\ 
    \end{pmatrix} \]</p>

<pre><code>import numpy as np
from pprint import pprint

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
pprint(x)
# =&gt;
# array([[1, 2, 3],
#        [4, 5, 6],
#        [7, 8, 9]])

pprint(x[:,0])
# =&gt;
# array([1, 4, 7])

pprint(x[:,1])
# =&gt;
# array([2, 5, 8])

pprint(x[:,1:2])
# =&gt;
# array([[2],
#        [5],
#        [8]])

pprint(x[:,1:3])
# =&gt;
# array([[2, 3],
#        [5, 6],
#        [8, 9]])
</code></pre>

<p>行単位で取り出す例</p>

<pre><code>import numpy as np
from pprint import pprint

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

pprint(x[0,:])
# =&gt;
# array([1, 2, 3])

pprint(x[1:3,:])
# =&gt;
# array([[4, 5, 6],
#        [7, 8, 9]])
</code></pre>

<h3 id="f65420e">行列の転置を求めるには
<span class="article-date">2014/05/18</span></h3>

<p>2次元配列に対して<code>T</code>メソッドを呼ぶだけでよい。</p>

<p>\[ \mathbf{X} =
    \begin{pmatrix}
      1 &amp; 2 \\ 
      3 &amp; 4 \\ 
    \end{pmatrix} \]</p>

<p>\[ \mathbf{X}^T =
    \begin{pmatrix}
      1 &amp; 3 \\ 
      2 &amp; 4 \\ 
    \end{pmatrix} \]</p>

<pre><code>import numpy as np
from pprint import pprint

X = np.array([[1, 2], [3, 4]])
pprint(X.T)
# =&gt;
# array([[1, 3],
#        [2, 4]])

# 以下のようにNumPyでない普通の配列に対して T を呼びだそうとすると
# AttributeError: 'list' object has no attribute 'T'
# というエラーが発生する
# X = [[1, 2], [3, 4]]
</code></pre>

<h3 id="d90f95c">行列の固有値・固有ベクトルを求めるには
<span class="article-date">2014/05/14</span></h3>

<p><code>scipy.linalg.eig</code> 関数を使う。</p>

<p>例</p>

<p>任意の行列:</p>

<p>\[ \mathbf{X} =
    \begin{pmatrix}
      2 &amp; 3 \\ 
      1 &amp; 4 \\ 
    \end{pmatrix} \]</p>

<p>固有ベクトルを並べたもの:</p>

<p>\[ \mathbf{S} =
    \begin{pmatrix}
      -0.95 &amp; -0.71 \\ 
      0.32 &amp; -0.71 \\ 
    \end{pmatrix} \]</p>

<p>固有値の対角行列:</p>

<p>\[ \mathbf{\Lambda} =
    \begin{pmatrix}
      1.00 &amp; 0 \\ 
      0 &amp; 5.00 \\ 
    \end{pmatrix} \]</p>

<p>積:</p>

<p>\[ \mathbf{X} \mathbf{S} = \mathbf{S} \mathbf{\Lambda} = \begin{pmatrix}
    -0.95 &amp; -3.54 \\ 
    0.32 &amp; -3.54 \\ 
    \end{pmatrix} \]</p>

<pre><code>import numpy as np
from scipy import linalg as la

x = np.array([[2, 3], [1, 4]])

lam, s = la.eig(x)

print(lam)
# [ 1.+0.j  5.+0.j]

print(s)
# [[-0.9486833  -0.70710678]
#  [ 0.31622777 -0.70710678]]

lam = np.diag(lam)
print(lam)
# [[ 1.+0.j  0.+0.j]
#  [ 0.+0.j  5.+0.j]]

print(x.dot(s))
# [[-0.9486833  -3.53553391]
#  [ 0.31622777 -3.53553391]]

print(s.dot(lam))
# [[-0.94868330+0.j -3.53553391+0.j]
#  [ 0.31622777+0.j -3.53553391+0.j]]
</code></pre>

</div>

<div id="side-menu">
  <div id="side-menu-attention">
    このサイトは筆者(hydrocul)の個人メモの集合です。すべてのページは永遠に未完成です。
  </div>
  <div id="side-menu-ls">
    <ul>
  <li><a href="../others/">未分類</a>
    <ul>
      <li><a href="../others/apache.html">Apache</a></li>
      <li><a href="../others/css.html">CSSのTips</a></li>
      <li><a href="../others/emacs.html">Emacsのメモ</a></li>
      <li><a href="../others/google-analytics.html">Google Analytics のAPIとRubyでのサンプル</a></li>
      <li><a href="../others/html.html">HTMLのTips</a></li>
      <li><a href="../others/ie.html">Internet Explorer</a></li>
      <li><a href="../others/javascript.html">JavaScriptのTips</a></li>
      <li><a href="../others/jquery.html">jQueryのTips</a></li>
      <li><a href="../others/jvm.html">JVM (Java仮想マシン)</a></li>
      <li><a href="../others/linux.html">Linux</a></li>
      <li><a href="../others/linux-pkg-manager.html">Linuxでのパッケージマネージャ別の基本操作</a></li>
      <li><a href="../others/mac.html">Macに関するいくつかのメモ</a></li>
      <li><a href="../others/matplotlib.html">Pythonのmatplotlibの使い方メモ</a></li>
      <li><a href="../others/mpdf-html-pdf-php.html">mPDF: HTMLをPDFに変換するPHPのライブラリ</a></li>
      <li><a href="../others/mysql.html">MySQLのメモ</a></li>
      <li>NumPy</li>
      <li><a href="../others/oneliner.html">ワンライナー</a></li>
      <li><a href="../others/passenger.html">Passenger (Ruby on Rails) のメモ</a></li>
      <li><a href="../others/phantomjs.html">phantomjsのメモ</a></li>
      <li><a href="../others/php.html">PHP</a></li>
      <li><a href="../others/php-ini-location.html">Ubuntuでの php.ini の場所</a></li>
      <li><a href="../others/php-post-curl.html">PHPのcURL関数を使って、HTTPのPOSTをするサンプル</a></li>
      <li><a href="../others/ruby.html">Ruby</a></li>
      <li><a href="../others/test-on-ie.html">Internet Explorer の検証環境</a></li>
      <li><a href="../others/unicode.html">Unicode</a></li>
    </ul>
  </li>
</ul>

  </div>
</div>

<footer>
  <a href="../">目次</a>
  <!-- Copyright &copy; 2012- @hydrocul All Rights Reserved. -->
</footer>

</body>
</html>
